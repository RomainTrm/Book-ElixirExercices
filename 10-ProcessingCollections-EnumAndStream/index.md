# 10. Processing collections - Enum and Stream

There are two modules available to manipulate collections:  

- `Enum` that is the workhorse for collections
- `Stream` that let us iterate through collections lazily (computes the next item when it is needed)

## Enum - processing collections

Many functions are available, like `concat`, `map`, `filter`, `reject`, `sort`, `take`, `split`, `all?`, `any?` and so on.  
See `Enum` [documentation](https://hexdocs.pm/elixir/1.12/Enum.html#functions) for all available functions.  
`Enum` module is greedy, when we pass it a collection, it potentially consumes all the content:  

```elixir
[1, 2, 3, 4, 5]
|> Enum.map(&(&1*&1))
# => [1, 4, 9, 16, 25]
|> Enum.with_index
# => [{1, 0}, {4, 1}, {9, 2}, {16, 3}, {25, 4}] 
|> Enum.map(fn {value, index} -> value - index end)
# => [1, 3, 7, 13, 21]
```

In this example, the list is fully iterated at every new function call. For a 5-element list, we made 15 iterations that is suboptimal.

## Streams - Lazy enumerables

Documentation of all `Stream` functions is available [here](https://hexdocs.pm/elixir/1.12/Stream.html#functions).

### A Stream is a composable enumerator

A Stream is an enumerator, this allows us to compose functions and then iterate through the source collection only once. If we rewrite our previous example:  

```elixir
[1, 2, 3, 4, 5]
|> Stream.map(&(&1*&1))
#Stream<[enum: [1, 2, 3, 4, 5], 
         funs: [#Function<49.117496853/1 in Stream.map/2>]]>
|> Stream.with_index
#Stream<[enum: [1, 2, 3, 4, 5], 
         funs: [#Function<49.117496853/1 in Stream.map/2>, 
                #Function<67.117496853/1 in Stream.with_index/2>]]>
|> Stream.map(fn {value, index} -> value - index end)
#Stream<[enum: [1, 2, 3, 4, 5], 
         funs: [#Function<49.117496853/1 in Stream.map/2>, 
                #Function<67.117496853/1 in Stream.with_index/2>, 
                #Function<49.117496853/1 in Stream.map/2>]]>
|> Enum.to_list # Iterate to get the result
# => [1, 3, 7, 13, 21]
```

We've never created an intermediate list, we are now passing elements through a chain of transformations.  
Note the iex returned to us the signature of the Stream, we can see a list of the chained functions.  

### Infinite streams

Thanks to laziness, we don't need a collection to be available upfront to pick some elements:  

```elixir
iex> Enum.map(1..10_000_000, &(&1 + 1)) |> Enum.take(5)
[2, 3, 4, 5, 6] # Result returned after a few seconds
iex> Stream.map(1..10_000_000, &(&1 + 1)) |> Enum.take(5)
[2, 3, 4, 5, 6] # Instantaneous result
```

### Creating your own streams

#### Stream.cycle

Takes an enumerable and return an infinite stream from it:  

```elixir
iex> Stream.cycle(1..3) |> Enum.take(8)
[1, 2, 3, 1, 2, 3, 1, 2]
```

#### Stream.repeatedly

Takes a function a calls it every time an element is needed:  

```elixir
iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)
[0.4435846174457203, 0.7230402056221108, 0.94581636451987]
```

#### Stream.iterate

Generate an infinite stream from two arguments: the initial value and a function to apply to the last returned value:  

```elixir
iex> Stream.iterate(0, &(&1+3)) |> Enum.take(5)
[0, 3, 6, 9, 12]
```

#### Stream.unfold

Successive values are generated by calling a function with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns `nil`.  

```elixir
iex> Stream.unfold(5, fn 0 -> nil
...>                     n -> { n, n - 1 }
...>               end)
...> |> Enum.to_list
[5, 4, 3, 2, 1]
```

#### Stream.resource

`resource` is built on top of `unfold` to allow us to read values from various sources (a file, a DB cursor, etc.).  
It takes a function to open a resource instead of an initial value, and a third argument that is a function called to close the resource once the stream is done.  

```elixir
defmodule Countdown do
  def sleep(seconds) do
    receive do
      after seconds * 1000 -> nil
    end
  end

  def timer do
    Stream.resource(
      fn ->                # the number of seconds to the start of the next minute
        {_h, _m, s} = :erlang.time
        60 - s - 1
      end,
      fn 0     -> {:halt, nil} # Wait for next second then return its countdown
         count -> sleep(1)
                  { [inspect(count)], count - 1}
      end,
      fn _ -> nil end      # nothing to deallocate
    )
  end
end
```

If we call it:  

```elixir
iex(24)> Countdown.timer |> Stream.each(&IO.puts/1) |> Enum.take(5)
6 # Print one output per second
5
4
3
2
["6", "5", "4", "3", "2"]
```

## The Collectable protocol

`Enumerable` protocol lets us iterate through a collection, the `Collectable` allows us to build collections by inserting elements.  
Not all collections are collectable (example: Ranges).  

```elixir
iex(25)> Enum.into 1..5, []
[1, 2, 3, 4, 5]
iex(26)> Enum.into 1..5, [100, 150]
[100, 150, 1, 2, 3, 4, 5]
# Note: into seems to be a deprecated function
```

## Comprehension

We've seen the `for` syntax to iterate through a collection, it can be used for comprehension.  

Syntax: `result = for generator or filter [, into: value], do: expression`  

```elixir
iex> for x <- 1..10, x < 5, do: x * x
[1, 4, 9, 16]
iex> for x <- [1, 2], y <- [4, 5], do: {x, y}
[{1, 4}, {1, 5}, {2, 4}, {2, 5}]
iex> for {min,max} <- [{1,4},{2,3}], n <- min..max, do: n
[1, 2, 3, 4, 2, 3]
```

### Comprehension works for Bits too

```elixir
iex> for << ch <- "Hello" >>, do: <<ch>>
["H", "e", "l", "l", "o"]
```

### Scoping and Comprehensions

All variables of a for comprehension are local and cannot be accessed from the outer scope.  

### The value returned by a comprehension

By default, a for comprehension returns a list, but we can retrieve the result by using the `:into` parameter:  

```elixir
iex> for x <- ~w{ cat dog }, into: %{"ant" => "ANT"}, do: {x, String.upcase(x)}
%{"ant" => "ANT", "cat" => "CAT", "dog" => "DOG"}
```
